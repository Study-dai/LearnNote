理解类型装换
java作为一个强类型变成语言，当不同类型之间的变量相互赋值的时候，会有严格的校验
int和long /double相互赋值

int a = 10; 
long b = 20; 
a = b;         // 编译出错, 提示可能会损失精度. 
 b = a;        // 编译通过.  
 
int a = 10; 
double b = 1.0;
 a = b;      // 编译出错, 提示可能会损失精度. 
 b = a;      // 编译通过.  
1
2
3
4
5
6
7
8
9
long 表示的范围更大, 可以将 int 赋值给 long, 但是不能将 long 赋值给 int.
double 表示的范围更大, 可以将 int 赋值给 double, 但是不能将 double 赋值给 int.
结论: 不同数字类型的变量之间赋值, 表示范围更小的类型能隐式转换成范围较大的类型, 反之则不行.

int和boolean相互赋值

int a = 10;
 boolean b = true;
  b = a;   // 编译出错, 提示不兼容的类型
  a = b;  // 编译出错, 提示不兼容的类型 
1
2
3
4
结论: int 和 boolean 是毫不相干的两种类型, 不能相互赋值.
int 字面值常量给byte赋值

byte a = 100;   // 编译通过
byte b = 256;    // 编译报错, 提示 从int转换到byte可能会有损失
1
2
注意: byte 表示的数据范围是 -128 -> +127, 256 已经超过范围, 而 100 还在范围之内.
结论: 使用字面值常量赋值的时候, Java 会自动进行一些检查校验, 判定赋值是否合理
使用强制类型转换

int a = 0;
 double b = 10.5;
  a = (int)b; 

int a = 10; 
boolean b = false;
 b = (boolean)a; 
 // 编译出错, 提示不兼容的类型. 
1
2
3
4
5
6
7
8
类型转换小结

不同数字类型的变量之间赋值, 表示范围更小的类型能隐式转换成范围较大的类型.
如果需要把范围大的类型赋值给范围小的, 需要强制类型转换, 但是可能精度丢失.
将一个字面值常量进行赋值的时候, Java 会自动针对数字范围进行检查.