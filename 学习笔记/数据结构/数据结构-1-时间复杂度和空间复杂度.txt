时间复杂度和空间复杂度
我们平时写代码需要关注“效率”
我们所谓的时间复杂度关注的是程序运行时的快慢（时间上的效率）
空间复杂度程序运行时占用的内存/外存的空间的多少
衡量的是一段代码的效率
这段代码在什么样的机器上执行，什么样的环境上执行（不确定）
如果一段代码中，存在一些基本操作，如果这样的基本操作重复次数越多，就可以认为代码越慢(以代码执行次数来表示快慢、速度、效率）

例如在一个数组中按顺讯查找指定的元素
如果元素个数是100，最好情况是1次，最坏情况是100次
如果元素个数是1w，最好情况是1次，最坏情况是1w次
如果元素个数是n，最好情况是1次，最坏情况是n次
这里我们就说，数组顺序查找时间内复杂度O(N)，
这里的N表示元素个数
O(N)表示基本操作执行了多少次
算法中基本操作执行的次数，为算法的时间复杂度

O渐进表示法，只是关注基本操作执行次数的数量级，不必算得很精确
如果最高项代系数，也不要系数，只关注数量级，只关注大概是多少，而不关注具体的精确的次数。

O(1)的运行时间不一定就比O(N)的短
冒泡排序的时间复杂度为O(N^2)
二分查找为O(log N）
阶乘递归为O(N)
斐波那契数列递归fib(100)
这就有100层数字，所以fib(N)就有N层数字
从下往上 第一层是2^N 第二层是2^（N-1）
总是：2N+2(N-2)+2(N-3)+…+22+2^1 次
只需要估算最大数量级项，这个时间复杂度就是O(2^N);

空间复杂度
空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度。空间复杂度不是程序占用了多少bytes 的空间，因为这个也没太大意义，所以空间复杂度算的是变量的个数。空间复杂度计算规则基本跟时间复杂度类似，也使用大O渐进表示法。

冒泡排序算法
// 计算bubbleSort的空间复杂度？

void bubbleSort(int[] array) {  
for (int end = array.length; end > 0; end--) {
      boolean sorted = true;
      for (int i = 1; i < end; i++) {
      if (array[i - 1] > array[i]) { 
      Swap(array, i - 1, i); 
      sorted = false; 
       } 
   } 
     if (sorted == true) {
               break;
                     } 
          } 
  } 

使用了常数个额外空间所以空间复杂度为O(1)

创建了三个变量 空间复杂度为O(1);

斐波那契求递归
每次递归都要创建一个临时变量
所以空间复杂度为O(N)
代码：
// 计算fibonacci的空间复杂度？

 int[] fibonacci(int n) {
   long[] fibArray = new long[n + 1];
     fibArray[0] = 0;
       fibArray[1] = 1; 
        for (int i = 2; i <= n ; i++) {
             fibArray[i] = fibArray[i - 1] + fibArray [i - 2];
         } 
 return fibArray; 
 }


